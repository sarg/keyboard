* base
** left
#+name: l0
| ESC  | Q   | W         | E         | R         | T           |
| TAB  | A   | LALT_T(S) | LCTL_T(D) | LSFT_T(F) | G           |
| MINS | Z   | X         | C         | V         | B           |
| XXX  | ENT | LGUI      | LALT      | MO(1)     | LGUI_T(ENT) |
** right
#+name: r0
| Y           | U         | I         | O         | P    | BSPC |
| H           | RSFT_T(J) | RCTL_T(K) | RALT_T(L) | SCLN | QUOT |
| N           | M         | COMM      | DOT       | SLSH | BSLS |
| RALT_T(SPC) | MO(2)     | RALT      | RGUI      | ENT  | XXX  |
** encoders
#+name: e0
| PGUP | PGDN  |
| UP   | DOWN  |
* digits
** left
#+name: l1
| GRV | 1       |  2 | 3     | 4    |  5 |
|     |         |    | PGUP  | PGDN |    |
| F1  | F2      | F3 | F4    | F5   | F6 |
| XXX | QK_BOOT |    | TO(3) |      |    |
** right
#+name: r1
| 6    | 7    | 8  | 9    | 0    | MINS |
| LEFT | DOWN | UP | RGHT |      |      |
| F7   | F8   | F9 | F10  | F11  | F12  |
| RSFT |      |    |      | MPLY | XXX  |
** encoders
#+name: e1
| VOLD | VOLU |
| VOLD | VOLU |
* symbols
** left
#+name: l2
| TILD | EXLM | AT | HASH | DLR | PERC |
|      |      |    |      |     |      |
|      |      |    |      |     |      |
| XXX  |      |    |      |     | LSFT |
** right
#+name: r2
| CIRC | AMPR | LPRN | RPRN | ASTR |     |
| MINS | EQL  | LBRC | RBRC |      |     |
| UNDS | PLUS | LCBR | RCBR |      |     |
|      |      |      |      |      | XXX |
** encoders
#+name: e2
| MEDIA_NEXT_TRACK | MEDIA_PREV_TRACK |
| UP               | DOWN             |
* gaming
** left
#+name: l3
| ESC   | 7 | 8    | 1    |    2 |   3 |
| GRV   | 9 | LEFT | UP   | RGHT |   4 |
| TO(0) | 0 | Q    | DOWN |    6 |   5 |
| XXX   |   | ENT  | TRNS |    C | SPC |
** right
#+name: r3
|   |   |   |   |   |     |
|   |   |   |   |   |     |
|   |   |   |   |   |     |
|   |   |   |   |   | XXX |
** encoders
#+name: e3
|   |   |
|   |   |
* keymap.json
#+name: helper
#+begin_src elisp :results none
(defun qmk/keyname (k)
  (let* ((m (and (stringp k)
                 (s-match (rx (group (+? anychar)) "("
                              (group (+ anychar) ")"))
                          k)))
         (fn (and m (nth 1 m)))
         (arg (and m (nth 2 m)))
         (fn-as-is (member fn '("MO" "TO"))))

    (cond
     ((numberp k) (format "KC_%d" k))
     ((string-empty-p k) "KC_NO")
     ((string-equal "XXX" k) nil)
     (fn-as-is k)
     (fn (concat fn "(KC_" arg))
     ((s-starts-with? "QK_" k) k)
     (t (concat "KC_" k)))))
#+end_src

#+name: layer
#+begin_src elisp :var l=l0 :var r=r0
(->>
 (-zip-with #'append l r)
 (-flatten)
 (-map #'qmk/keyname)
 (-filter #'identity)
 (-map (lambda (k) (format "%S" k)))
 (s-join ",\n"))
#+end_src

#+name: encoder
#+begin_src elisp :var e=e0
(s-join
 ", "
 (-map
  (lambda (enc)
    (apply #'format "{\"ccw\": %S, \"cw\": %S}"
           (-map #'qmk/keyname enc)))
  e))
#+end_src

#+begin_src js :tangle firmware/keymaps/default/keymap.json :noweb yes
{
  "version": 1,
  "notes": "",
  "documentation": "generated by org-mode",
  "author": "",
  "keyboard": "emajesty/eiri",
  "keymap": "keymap",
  "layout": "LAYOUT",
  "encoders": [
      [<<encoder(e0)>>],
      [<<encoder(e1)>>],
      [<<encoder(e2)>>],
      [<<encoder(e3)>>]
  ],
  "layers": [
    [
      <<layer(l0,r0)>>
    ],
    [
      <<layer(l1,r1)>>
    ],
    [
      <<layer(l2,r2)>>
    ],
    [
      <<layer(l3,r3)>>
    ]
  ]
}
#+end_src

#+name: cencoder
#+begin_src elisp :var e=e0 :var l=0
(s-join
 ",\n"
 (-map-indexed
  (lambda (idx enc)
    (format "{ %d, %d, false, %s },\n{ %d, %d, true, %s }"
            l idx (qmk/keyname (nth 0 enc))
            l idx (qmk/keyname (nth 1 enc))))
  e))
#+end_src

#+name: clayer
#+begin_src elisp :var l=l0 :var r=r0 :var i=0
(concat
(s-join ",\n"
        (-filter #'identity
        (-flatten
         (-map-indexed
          (lambda (row keys)
            (-map-indexed
             (lambda (col key)
               (when-let ((skey (qmk/keyname key)))
                  (format "{ %d, %d, %d, %s }" i row col skey)))
             keys))
          (append l (-map #'reverse r)))))))
#+end_src

#+begin_src c :tangle write_eeprom/keymap.h :noweb yes
#include <quantum_keycodes.h>
#include <modifiers.h>
#include <stdint.h>

typedef struct KEY {
  uint8_t layer;
  uint8_t row;
  uint8_t col;
  uint16_t keycode;
} KEY;

const KEY keys[] = {
  <<clayer(l0, r0, 0)>>,
  <<clayer(l1, r1, 1)>>,
  <<clayer(l2, r2, 2)>>,
  <<clayer(l3, r3, 3)>>
};

typedef struct ENCODER {
  uint8_t layer;
  uint8_t idx;
  bool clockwise;
  uint16_t keycode;
} ENCODER;

const ENCODER encoders[] = {
  <<cencoder(e0, 0)>>,
  <<cencoder(e1, 1)>>,
  <<cencoder(e2, 2)>>,
  <<cencoder(e3, 3)>>
};
#+end_src
